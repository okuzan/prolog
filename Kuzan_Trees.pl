% btr(btr(btr(nil, 'A', nil), 'B', btr(btr(nil, 'C', nil), 'D', btr(nil, 'E', nil))), 'F', btr(nil, 'G', btr(btr(nil, 'H', nil), 'I', nil)))
% btr(btr(btr(nil, 1, nil), 2, btr(btr(nil, 3, nil), 4, btr(nil, 5, nil))), 6, btr(nil, 7, btr(btr(nil, 8, nil), 9, nil)))
% n2( n2( n3(l(1), 3, l(3), 4, l(4) ), 5, n2( l(5), 7, l(7) ) ), 8, n2( n3( l(8), 10, l(10), 12, l(12) ), 13, n2( l(13), 15, l(15) ) ) )
% n2( n2( n3(l(1), 3, l(3), 4, l(4) ), 5, n2( l(5), 7, l(7) ) ), 8,  l(13)) )


%____________________________________________________________________________
%1 - Послідовності вузлів при обході в глибину бінарного дерева праворуч.
% z13_1(+Tree, -List) - послідовність вузлів, серединний обхід(inorder).
% z13_1(+Tree, +List) - чи правда що це послідовність вузлів цього дерева при обході праворуч.
z13_1(nil,[]).
z13_1(btr(Left, Root, Right), List) :- z13_1(Left, ListL), 
                                       z13_1(Right, ListR),
                                       append(ListL, [Root|ListR], List).

%2 - Визначення кількості листків бінарного дерева.
%z13_2(+Tree, -N) - скільки листків у дерева
%z13_2(+Tree, +N) - чи правда, що у дерева N листків

z13_2(btr(nil, _, nil), 1). %=листок
z13_2(btr(Left, _, nil), N) :- z13_2(Left, N).
z13_2(btr(nil, _, Right), N) :- z13_2(Right, N).
z13_2(btr(Left, _, Right), N) :- z13_2(Left, N1), z13_2(Right, N2), N is N1 + N2. % сума двох піддерев.

%3 - Визначення висоту бінарного дерева.
% z13_3(+Tree, -Height) - скільки листків у дерева
% z13_3(+Tree, +Height) - чи правда, що у дерева така висота

z13_3(nil, 0). %базовий випадок
z13_3(btr(Left, _, Right), N) :- z13_3(Left, N1), z13_3(Right, N2), N is max(N1, N2) + 1. %виосота більшого з піддерев + 1

%4 - Визначення кількість вузлів у бінарному дереві.
% z13_4(+Tree, -N) - скільки вузлів у дерева
% z13_4(+Tree, +N) - чи правда, що у дерева N вузлів

z13_4(nil, 0).
z13_4(btr(Left, _, Right), N) :- z13_4(Left, N1), z13_4(Right, N2), N is N1 + N2 + 1.

%5 - Обхід 2-3-дерева.
%z13_5(+Tree,-List) - список вузлів дерева.
%z13_5(+Tree,+List) - чи правда, що у дерева такий список вузлів.

z13_5(nil,[]).
z13_5(l(R), [R]). %лист - повернути один елемент
z13_5(n2(D1, _, D2), R) :- z13_5(D1, R1), z13_5(D2, R2), append(R1, R2, R). %повернути рекурсивно результат лівого та правого
z13_5(n3(D1, _, D2, _, D3), R) :- 
               z13_5(D1, R1), 
               z13_5(D2, R2), 
               z13_5(D3, R3), 
               append(R1, R2, Rr1), % поєднюємо результати трьох рекурсивних спусків
               append(Rr1, R3, R).


% 6 - Пошуку заданого елемента в 2-3-дереві
% z13_6(+Tree, +E) - чи правда, що елемент Е можна знайти у даному дереві
% z13_6(+Tree, -E) - вивести всі значення вузлів дерева

z13_6(Tree, E) :- z13_5(Tree, List), member(E, List).

% 7 - Написати програму, яка перевірить чи є заданий об'єкт бінарним деревом
%z13_7(+Tree) - true if it's BST, false otherwise

z13_7(T) :- once(z13_71(T)).
z13_71(nil).
z13_71(btr(Left, Root, Right)) :- 
                                 z13_1(Left, LList),
                                 z13_1(Right, RList),
                                 checkL(LList, Root),
                                 checkR(RList, Root),
                                 z13_7(Left),       
                                 z13_7(Right).

% первірка, чи Рут менший за найменший елемент правого піддерева
checkR([], _).
checkR(RList, Root) :- sort(RList, [H|_]), Root < H.

% первірка, чи Рут більший за найбільший елемент лівого піддерева
checkL([], _).
checkL(LList, Root) :- sort(LList, LList2), last(H, LList2), Root > H.

%8 Написати програму, яка перевірить чи є заданий об'єкт 2-3 деревом
z13_8(nil).
z13_8(l(_)).

% перевірити, чи є М найменшим елементом правого піддерева, 
% чи всі листки на одному рівні, чи піддерева валідні, рекурсія
z13_8(n2(D1, M, D2)) :- z13_8(D1),
                        z13_8(D2),
                        min(D2, M),
                        height23(n2(D1, M, D2), _).

% перевірити, чи є М2 найменшим елементом середьного піддерева, 
% а  М3 найменшим елементом правого піддерева, чи всі листки на одному рівні, чи піддерева валідні, рекурсія

% 8 - Чи є заданий об'єкт 2-3 деревом
%z13_8(+Tree) - true якщо є 2-3 деревом, інакше false 

z13_8(n3(D1, M2, D2, M3, D3)) :- z13_8(D1), 
                                 z13_8(D2), 
                                 z13_8(D3),
                                 min(D2, M2),
                                 min(D3, M3),
                                 height23(n3(D1, M2, D2, M3, D3), _).



% ДОПОМІЖНІ
% Перевірка висоти 2-3 дерева
% height23(+Tree, -Height) - отримати висоту 2-3 дерева.
% якщо дерево має гілки різної висоти, повернеться false.

% height23(+Tree, -Height) - отримати висоту 2-3 дерева
% height23(+Tree, +Height) - перевірити, чи це справді висота 2-3 дерева
height23(nil, 0).
height23(l(_), 1).
height23(n2(D1, _, D2), H) :-  height23(D1, H1), 
                               height23(D2, H2), 
                               H1 = H2, H is H1 + 1.

height23(n3(D1, _, D2, _, D3), H) :-  height23(D1, H1), 
	                                  height23(D2, H2), 
	                                  height23(D3, H3),
                                      H1 = H2, H2 = H3,
                                      H is H1 + 1.

% отримати найменший елемент правильного 2-3 дерева
% min(+Tree, -Elem) - return left-most node value.
min(nil, 0).
min(l(F), F).
min(n2(D1, _, _), F) :- min(D1, F).
min(n3(D1, _, _, _, _), F) :- min(D1, F).

% отримати останній елемент списку
last(L, [L]).
last(E, [_|L]) :- last(E, L).

% ТЕСТУВАННЯ
% ?- z13_1(btr(btr(btr(nil, 1, nil), 2, btr(btr(nil, 3, nil), 4, btr(nil, 5, nil))), 6, btr(nil, 7, btr(btr(nil, 8, nil), 9, nil))), List).
% List = [1, 2, 3, 4, 5, 6, 7, 8, 9].
% ?- z13_2(btr(btr(btr(nil, 1, nil), 2, btr(btr(nil, 3, nil), 4, btr(nil, 5, nil))), 6, btr(nil, 7, btr(btr(nil, 8, nil), 9, nil))), List).
% List = 4
% ?- z13_3(btr(btr(btr(nil, 1, nil), 2, btr(btr(nil, 3, nil), 4, btr(nil, 5, nil))), 6, btr(nil, 7, btr(btr(nil, 8, nil), 9, nil))), Height).
% Height = 4.
% ?- z13_4(btr(btr(btr(nil, 1, nil), 2, btr(btr(nil, 3, nil), 4, btr(nil, 5, nil))), 6, btr(nil, 7, btr(btr(nil, 8, nil), 9, nil))), KNodes).
% KNodes = 9.
% ?- z13_5(n2( n2( n3(l(1), 3, l(3), 4, l(4) ), 5, n2( l(5), 7, l(7) ) ), 8, n2( n2( l(8), 10, l(10)), 13, n2( l(13), 15, l(15) ) ) ), R).
% R = [1, 3, 4, 5, 7, 8, 10, 13, 15].
% ?- z13_6(n2( n2( n3(l(1), 3, l(3), 4, l(4) ), 5, n2( l(5), 7, l(7) ) ), 8, n2( n2( l(8), 10, l(10)), 13, n2( l(13), 15, l(15) ) ) ), 10).
% true
% ?- z13_6(n2( n2( n3(l(1), 3, l(3), 4, l(4) ), 5, n2( l(5), 7, l(7) ) ), 8, n2( n2( l(8), 10, l(10)), 13, n2( l(13), 15, l(15) ) ) ), 100).
% false
% 2-3 дерево з гілками різної висоти не проходить:
% ?- z13_8(n2( n2( n3(l(1), 3, l(3), 4, l(4) ), 5, n2( l(5), 7, l(7) ) ), 8,  l(13))).
% false.

% 2-3 дерево з книги Братка
%   бінарне дерево:
%
%           6
%
%       2       7        
%
%    1     4       9
%        3   5    8